\section{Discussion}
\label{sec:opts}

The challenge of navigating the physical design space has served as the
primary source of motivation for selection of a declarative language.  While
our implementation does not yet map a declarative specification on to a
particular physical design, the specification provides a powerful
infrastructure for automating this mapping and achieving other optimizations.
Given the declarative nature of the interfaces we have defined, we can draw
parallels between the physical design challenges described in this paper and
the large body of mature work in query planning and optimization.

Looking beyond standard forms of optimization decisions that seek to select
an appropriate mix of low-level I/O interfaces, data structure selection is an
important point of optimization. For instance in Section~\ref{sec:dspace} we
showed that using the bytestream for metadata management as opposed to the
key-value interface offered superior performance. However the unstructured
nature of the bytestream data model imposes no restrictions on implementation
or storage layout. Integration of common indexing techniques into an optimizer
combined with a performance model will allow our CORFU interface to derive
similar optimizations when appropriate. Similar degrees of freedom can be
imagined when handling other approaches to implementing the CORFU sequencer
service. Given its soft-state nature heavy-weight processes that enforce
durability can be circumvented in favor of shorter code paths that optimize
for throughput and latency.

The Bloom language that we use as a basis for a declarative specification
language produces a data flow graph that can be used in static analysis. We
envision that this graph will be made available to the OSD and used to reorder
and coalesce requests based on optimization criteria available from a
performance model combined with semantic information from the dataflow. For
example today object classes are represented as black boxes from the point of
view of the OSD execution engine.  Understanding the behavior of an object
class may allow intelligent prefetching. Another type of analysis that may be
useful for optimization is optimistic execution combined with branch
prediction where frequent paths through a dataflow are handled optimistically.

\section{Conclusion}

I can't believe this fits.
